@import 'empty';
@import 'extract';
@import 'number';
@import 'map';
@import 'split';
@import 'type';
@import 'replace';

/**
 * hasRef
 * Check if a map has a ooFormat
 * @param Map|String
 * @return Boolean
 */
 @function hasRef($search) {
  @return if(str-index(#{$search}, 'oo(') == null, false, true);
}

/**
 * isRef
 * Check if a string is a ooFormat
 * @param String  $string
 * @return Boolean
 */
@function isRef($string) {
  @if isNotString($string) {
    $string: #{$string};
  }
  @return str-slice($string, 1, 3) == 'oo(' and str-slice($string, str-length($string)) == ')';
}

/**
 * hasSpreadOperator
 * Check if a reference has the spread operator  
 * @param String  $ref
 * @return Boolean
 */
@function hasSpreadOperator($ref) {
  @return if(str-index(#{$ref}, '+oo(') == null, false, true);
}

/**
 * getRefValue
 * get the ooFormat reference
 * @param String  $string
 * @return String
 */
 @function getRefValue($string) {
  @if isNotString($string) {
    $string: #{$string};
  }
  @return str-slice($string, 4, -2);
}

/**
 * extractRef
 * extract the ooFormat reference from a string
 * @param String  $string The string to extract the ref from
 * @return String
 */
@function extractRef($string) {
  @if not hasRef($string) {
    @return $string;
  }

  $start: str-index(#{$string}, 'oo(');
  $length: str-length(#{$string});
  $end: null;

  @for $i from $start through $length {
    @if str-slice(#{$string}, $i, $i) == ')' {
      $end: $i;
      @return str-slice(#{$string}, $start, $end);
    }
  }

  @return $string;
}

/**
 * oo
 * Get value from a map with the ooFormat (default $ooLoop)
 * @param String  $key  ooFormat key
 * @param ?Map $map the map to update (default $ooLoop)
 * @return Map|List|String
 */
@function oo($key, $map:null) {
  $list: split('.', $key);
  $map: if($map == null, $ooLoop, $map);
  @for $i from 1 through length($list) {
    $map: getMapValue($map, nth($list, $i));
  }
  @return $map;
}

/**
 * ooSet
 * Set value in  to map with the ooFormat (default $ooLoop)
 * @param String  $key  ooFormat key
 * @param Map|List|String  $value  the new value to set
 * @param ?Map $map the map to update (default $ooLoop)
 * @return Map|List|String
 */
@function ooSet($key, $value, $map:null) {
  $list: split('.', $key);
  $map:  if($map == null, $ooLoop, $map);
  
  @if length($list) > 1 {
    $mapValue: $value;
    @for $i from 1 through length($list) {
      $mapValue: ( #{nth($list, length($list) - $i + 1)} : $mapValue );
    }
    $map: mapMergeDeep($map, $mapValue);
  } @else if isRef($value) {
    $ooRefVal: oo(getRefValue($value), $map);
    $mapValue: ooSet($key, $ooRefVal, $map);
    $map: mapMergeDeep($map, $mapValue);
  } @else {
    $map: setMapValue($map, $key, $value);
  }

  @return $map;
}

/**
 * ooAdd
 * Push new map value to an another set of map with the ooFormat (default $ooLoop)
 * @param String $key ooFormat key
 * @param Map|List $mapValue the value to add
 * @param ?Map $map the map to update (default $ooLoop)
 * @return Map
 */
@function ooAdd($key, $mapValue, $map:null) {
  $currentValue: oo($key, $map);

  @if (isRef($currentValue)) {
    $currentValue: oo(getRefValue($currentValue), $map);
  }

  @if isList($currentValue) {
    $newValue: ooSet($key, append($currentValue, $mapValue), $map);
    @return $newValue;
  }
    
  $newValue: ooSet($key, mapMergeDeep($currentValue, $mapValue), $map);
  @return $newValue;
}


/**
 * ooParse
 * Parse a map of data with potential ooReference within (at this stage the oo() does not exist
 * @param Map  $map
 * @param Map  $backup the backupMap to refer to when getting data in a nested map
 * @param String  $path  a ooPathFormat to keep in mind where we are in a nested map
 * @return Map
 */
@function ooParse($map, $backup:null, $path:'') {
  $parentMap: if($backup == null, $map, $backup);
  
  @each $key, $value in $map {
    @if isMap($value) {
      // set path to remember where we can from in a nested environment
      $path: if(isEmpty($path), '#{$key}', '#{$path}.#{$key}');
      $newValue: ooParse($value, $parentMap, $path);
      $map: setMapValue($map, $key, $newValue);
      // clear latest child in path to go backup in the nested environment 
      $path: if(length(split('.', $path)) > 1, replace('.#{$key}', '', $path), replace('#{$key}', '', $path));
    } 
    @else if hasRef($value) {
      $ooRef: extractRef($value);
      $newValue: oo(getRefValue($ooRef), $parentMap);

      @if hasSpreadOperator($value) and isList($value) {
        $refIndex: index($value, '+#{$ooRef}');
        @if isRef($newValue) {
          $newValue: set-nth($value, $refIndex, '+#{$newValue}'),
        } @else {
          @if isNotMap($newValue) {
            @error 'spread operator must extend a map type data';
          }
          $newMapValue: ();
          @for $i from 1 through length($value) {
            @if $i == $refIndex {
              $newMapValue: map-merge($newMapValue, $newValue);
            } @else {
              @if isNotMap(nth($value, $i)) {
                @error 'spread operator only works along map type data';
              }
              $newMapValue: map-merge($newMapValue, nth($value, $i));
            }
          }
          $newValue: $newMapValue;
        }
      }
      
      @if isList($value) and isNotMap($newValue) {
        $refIndex: index($value, $ooRef);
        $newListValue: ();
        @for $i from 1 through length($value) {
          @if (isAlias(nth($value, $i))) {
            @if hasRef($newValue) {
              $newListValue: append($newListValue, replace($ooRef, $newValue, nth($value, $i)));
            } @else {
              $newListValue: append($newListValue, getAliasValue(nth($value, $i), $newValue));
            }
          } @else if ($i == $refIndex) {
            $newListValue: append($newListValue, $newValue)
          } @else {
            $newListValue: append($newListValue, nth($value, $i))
          }
        }
        $newValue: $newListValue;
      }

      @if isAlias($value) and isNotList($value) {
        @if hasRef($newValue) {
          $newValue: replace($ooRef, $newValue, $value);
        } @else {
          $newValue: getAliasValue($value, $newValue);
        }
      }

      $map: ooSet($key, $newValue, $map);

      //update backup
      @if isEmpty($path) {
        $parentMap: mapMergeDeep($parentMap, $map);
      } @else {
        $parentMap: ooSet($path, $map, $parentMap);
      }
    }
  }
  @return $map;
}

/** 
 * ooPrefix
 * get loop prefix
 * @return String
 */
@function ooPrefix() {
  @return if(oo(html5) == true, 'data-oo', 'oo');
}

$ooAlias: (
  (
    name: 'ooDarken',
    function: 'darken',
    params: ('color', 'number'),
  ),
  (
    name: 'ooLighten',
    function: 'lighten',
    params: ('color', 'number'),
  ),
);

/** 
 * Aliases function used before init
 */
@function ooDarken($value, $percentage) {
  @return darken($value, $percentage);
}
@function ooLighten($value, $percentage) {
  @return lighten($value, $percentage);
}

/** 
 * isAlias
 * check if a string is a sass alias function
 * @param String $string the string to check
 * @return Boolean
 */
@function isAlias($string) {
  $isAlias: false;
  @each $alias in $ooAlias {
    $aliasName: getMapValue($alias, 'name');
    $aliasLength: str-length($aliasName);
    @if str-slice(#{$string}, 1, $aliasLength + 1) == '#{$aliasName}(' and str-slice(#{$string}, str-length(#{$string})) == ')' {
      $isAlias: true;
    }
  }
  @return $isAlias;
}

/** 
 * getAliasValue
 * retrieve the value of an alias function
 * @param String $string The complete alias function
 * @param String $value Value of the 1st parameter
 * @return Boolean
 *
 * @todo review, simplify
 */
@function getAliasValue($string, $param:null) {
  $currentAlias: null;
  $function: null;
  $params: split(',', #{$string});

  $param1: nth($params, 1);
  @each $alias in $ooAlias {
    $aliasName: getMapValue($alias, 'name');
    $aliasLength: str-length($aliasName);
    @if str-slice($string, 1, $aliasLength) == $aliasName {
      $currentAlias: $alias;
      $function: getMapValue($alias, 'function');
      $param1: stripSpaces(str-slice($param1, $aliasLength + 2, str-length($param1)));
      @if function-exists('get-function') {
        $function: get-function($function);
      }
    }
  }

  $param1: if($param not null, $param, $param1);

  @if length($params) > 1 {
    $paramLeft: removeFromList($params, 1);
    $param2: stripSpaces(str-slice(#{$paramLeft}, 1, -2));

    $currentAliasParams: getMapValue($currentAlias, 'params');
    $param1: toType(nth($currentAliasParams, 1), $param1);
    $param2: toType(nth($currentAliasParams, 2), $param2);
    @return call($function, $param1, $param2);
  }
  @return call($function, $param1);
}
